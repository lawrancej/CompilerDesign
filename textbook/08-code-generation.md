\pagebreak

<!---
DO NOT REMOVE THIS COMMENT OR TOPICS LISTED HERE.

This section should cover these topics.
It need not be in this order.

Indicate coverage of topics by copying topic lines verbatim into a comment adjacent to the relevant text.
Covered topics appear twice in a file: here and adjacent to the relevant text.
Uncovered topics appear only once in a file (in this comment).

This command checks whether topic lines appear only once in a file.

    ./check.sh uncovered

TOPICS:

6.1 Overview
6.1.1 Produces Machine-Executable Code
6.1.2 Input Parse Tree
6.1.3 Output Machine Code
6.1.4 Includes Some Optimization Techniques
6.2 Process
6.2.1 Instruction Selection
6.2.1.1 Transforms Middle-Level IR to Low-Level IR
6.2.1.1.1 Middle Level IR
6.2.1.1.1.1 Tree-Based
6.2.1.1.1.2 Intermediate Representation
6.2.1.1.2 Low Level IR
6.2.1.1.2.1 Reduced From Tree
6.2.1.1.2.2 Close to Target Language (Machine Code)
6.2.1.2 Templates and Tiles
6.2.1.2.1 Tiles
6.2.1.2.1.1 Template That Matches a Portion of IR Tree
6.2.1.2.1.2 Implemented with a Single Target Instruction
6.2.1.2.2 Templates
6.2.1.2.2.1 Convert Code from IR to Target Language
6.2.1.2.2.2 Open to Optimization
6.2.1.2.3 Implementation
6.2.1.2.3.1 Backward Dynamic Programming
6.2.1.2.3.2 Greedy Algorithms
6.2.2 Instruction Scheduling
6.2.2.1 Optimization Technique
6.2.2.1.1 Reorders Instructions for Optimal Processing
6.2.2.1.2 Avoid Data Stalls and Code Structure Hazards
6.2.2.2 Types of Scheduling Algorithms
6.2.3 Register Allocation
6.2.3.1 Multiplexes Program Variables to CPU Registers
6.2.3.1.1 Maximize Program Execution Time
6.2.3.1.2 Occurrences
6.2.3.1.2.1 Local
6.2.3.1.2.2 Global
6.2.3.1.2.3 Interprocedural
6.2.3.2 NP-Complete Optimization Problem
6.2.4 Non-Standard Compilers
6.2.4.1 Just-In-Time Compilation
6.2.4.2 Profiling

-->

Code generation
===============

### What is code generation?
Code generation is the final [compiler phase](#what-are-the-phases-of-a-compiler).
It produces code in the target language, which is typically a machine language (e.g., x86, arm), but may be assembly or even a high-level language.

The code generator is distinct from the [parser](#what-is-a-parser) and the [translator](#what-is-a-translator).

Typical input for a code generator could be a parse or abstract syntax tree, which is translated into a set of instructions to be read at the machine level.

Code generators try to optimize the generated code by doing several different things including using faster instructions, using fewer instructions, exploit available registers, and avoid redundant computations.

The first stage of code generation is known as instruction selection, in which the compiler converts its input from some type of tree into a low level machine language, such as assembly language. Once intermediate tree instructions are loaded, they will be matched up peice by piece and converted into register operations using memory as sparingly as possible.

Once instructions are established, the compiler prioritizes them to enhance performance and speed. this can be a delicate procedure, as reordering instructions could cause a stall in processing. Algorithms used to schedule instructions aim to prevent bubbles and choose the best priority for instruction order.

Now that order has been determined, the compiler must allocation memory in registers to store the code'sinstructions. All of the variables created by the previous steps will be stored into empty allocated memory spaces. Since registers can only hold so much information, variables must be carefully tracked and stored. If registers become full, RAM can be used to store any overflow although this is costly and will slow down the overall execution speed of compilation. A good compiler will make excellent use of available registers and attempt to avoid spilling over into RAM.

A debug data format is created to store information from the compiled code so that a debugging process can interpret it at the source level. A debugging proccess handles both the machine and source languages as it interprets all variables, methods, types, and other outputs generated by the compiling process.

