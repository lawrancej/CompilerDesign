\pagebreak

<!---
DO NOT REMOVE THIS COMMENT OR TOPICS LISTED HERE.

This section should cover these topics.
It need not be in this order.

Indicate coverage of topics by copying topic lines verbatim into a comment adjacent to the relevant text.
Covered topics appear twice in a file: here and adjacent to the relevant text.
Uncovered topics appear only once in a file (in this comment).

This command checks whether topic lines appear only once in a file.

    ./check.sh uncovered

TOPICS:

3.1 Parsing Overview
3.1.1 Function
3.1.1.1 Input: Tokens from Lexical Analysis
3.1.1.2 Output: Program Parse Tree
3.1.2 Examples
3.1.2.1 Given an Arbitrary Function
3.1.2.2 Produce:
3.1.2.2.1 Parser Input
3.1.2.2.2 Parse Tree
3.1.3 Context-Free Grammar
3.2 Top-Down Parsing
3.2.1 Traversing a Parse Tree
3.2.1.1 Definition
3.2.1.2 Example
3.2.2 Backus-Naur Form Production Rules
3.2.3 LL Parser
3.2.4Process 
3.2.4.1 Starts at Left-most Symbol Yielded from Production Rule
3.2.4.2 Continues to Next Production Rule for Each Non-Terminal Symbol
3.2.4.3 Proceeds "Down" the Parse Tree
3.3 Bottom-Up Parsing
3.3.1 Bottom-Up
3.3.1.1 Definition
3.3.1.2 Example
3.3.2 Process
3.3.2.1 Identify Terminal Symbols First
3.3.2.2 Combine Terminal Symbol to Produce Nonterminals
-->

Parsing
=======
### What is a context-free language?
A language generated by [context-free grammar](#what-is-a-context-free-grammar).

### What is a context-free grammar?
A context-free grammar is a [formal grammar](#what-is-a-grammar) in which:

- The left-hand side of every [production](#what-is-a-production) is a single [nonterminal](#what-is-a-nonterminal) symbol.
- The right-hand side of every production is a sequence of terminals and nonterminals.
If the sequence is empty, as in $A \to \epsilon$, the nonterminal [derives](#what-is-a-derivation) the empty string.

#### Examples
This grammar is [context-free], but [improper](#what-is-an-improper-context-free-grammar), because it is impossible to derive B into just terminal symbols.
$B \to hB$

This grammar is [context-free](#what-is-a-context-free-grammar) and [regular](#what-is-a-regular-grammar) (it matches `h*`).
$B \to hB$
$B \to \epsilon$

This grammar is [context-free], but not [regular](#what-is-a-regular-grammar), since it has [left-recursion](#what-is-left-recursion) (it matches balanced parentheses).
$S \to S (S)$
$S \to \epsilon$

#### Follow-up questions

- [How can you tell if a language is context-free](#how-can-you-tell-if-a-language-is-context-free)?
- [Is English context-free](http://cs.haifa.ac.il/~shuly/teaching/08/nlp/complexity.pdf)?
- [When a language is context free, do terminals have only one meaning](#what-are-the-implications-of-chomskys-hierarchy)?
- [Is infinite recursion allowed in context-free grammars](#what-is-left-recursion)?

### How can you tell if a language is context-free?

### What is left recursion?

### What is the difference between a regular language and a context free language?

[Formal regular expressions](#what-is-a-regular-expression) define [regular languages](#what-is-a-regular-language),
and can be accepted by [deterministic and non-deterministic](#what-is-the-difference-between-deterministic-and-nondeterministic) [finite state machines](#what-is-a-finite-automaton).
Regular languages also do not accept arbitrary nesting, like [recursion](#what-is-recursion).
[Context-free grammars](#what-is-a-context-free-grammar) define context-free languages, and can be accepted by [pushdown automata](#what-is-a-pushdown-automaton) 

#### Example:

- The [language](#what-is-a-language) of balanced parentheses is context-free, but not regular.
Thus, it is impossible to construct a regular expression (but possible to construct a context-free grammar) that matches balanced parentheses.

### What is a derivation?
Give examples.

### What is a leftmost derivation?

### What is a rightmost derivation?

### What is an ambiguous grammar?

### What is a LL(k) grammar?

### What is a LR(k) grammar?

### What is Backus-Naur Form?
<!--3.2.3 LL Parser Kyle Cantrell-->

A BNF specification is a set of derivation rules, written as

 <symbol> ::= __expression__

where <symbol> is a nonterminal, and the __expression__ consists of one or more sequences of symbols; more sequences are separated by the vertical bar, '|', indicating a choice, the whole being a possible substitution for the symbol on the left.
Symbols that never appear on a left side are terminals.
On the other hand, symbols that appear on a left side are non-terminals and are always enclosed between the pair <>.

The '::=' means that the symbol on the left must be replaced with the expression on the right

### What is a pushdown automaton?
A pushdown automaton (PDA) is a finite state machine with [stack](#what-is-a-stack) memory.

It manipulates a stack by choosing an indexing variable within the stack, a current state, and a symbol at the top of the stack.


> TODO: It'd be nice to have a picture of a pushdown automaton, in a vector format such as SVG.

### What is a deterministic pushdown automaton?

### What is a nondeterministic pushdown automaton?

### What is a parser?
A parser:
- Checks for [syntax errors](#what-is-a-syntax-error)
- Constructs a [parse tree](#what-is-a-parse-tree) or an [abstract syntax tree](#what-is-an-abstract-syntax-tree).

Typically, a [scanner](#what-is-a-scanner) first [tokenizes](#what-is-tokenization) the source code into a [token](#what-is-a-token) [sequence](#what-is-a-sequence) that the parser reads as input.
However, scanner-less parsers work directly with source code as input.

Parsers do not [produce assembly or object code](#what-is-code-generation).

Follow ups:
- [How do parsers work](#how-do-parsers-work)?

### What is a syntax error?
> TODO: this section needs fixing.
state what a syntax error is.

A parser first tokenizes the source code depending on its syntax.
It takes the structure of the code and uses said tokens to convert it to object code.
After evaluation it will convert it to ASM code if there are no syntax errors.

### What is a parse tree?

A parse tree for a grammar G is a tree where

    -the root is the start symbol for G

    -the interior nodes are the nonterminals of G

    -the leaf nodes are the terminal symbols of G.

    -the children of a node T (from left to right) correspond to the symbols on the right hand side of some production for T in G.


Every terminal string generated by a grammar has a corresponding parse tree; every valid parse tree represents a string generated by the grammar (called the yield of the parse tree). 

### How do parsers work?
