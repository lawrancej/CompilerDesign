
\pagebreak
>TODO : The next step of the compilation process is parsing.  Parsing takes input from the Lexical Analysis step and builds a parse tree, which will be used in future steps to develop the machine code.  In this unit, we will define parsing and identify its uses.  We will also discuss two parsing strategies, Top-Down Parsing and Bottom-Up Parsing, examining what it means to approach parsing from each standpoint and taking a look at an example of each.  By the end of the unit, you will understand parsing techniques with regards to compilers and be able to discuss each of the two main approaches. 


Parsing
=======
>TODO Parsing Overview
### What is a context-free language?
A language generated by [context-free grammar](#what-is-a-context-free-grammar).

### What is a context-free grammar?
A context-free grammar is a [formal grammar](#what-is-a-grammar) in which:

- The left-hand side of every [production](#what-is-a-production) is a single [nonterminal](#what-is-a-nonterminal) symbol.
- The right-hand side of every production is a sequence of terminals and nonterminals. If the sequence is empty, as in $A \to \epsilon$, the nonterminal [derives](#what-is-a-derivation) the empty string.

#### Examples
This grammar is [context-free], but [improper](#what-is-an-improper-context-free-grammar), because it is impossible to derive B into just terminal symbols.
$B \to hB$

This grammar is [context-free](#what-is-a-context-free-grammar) and [regular](#what-is-a-regular-grammar) (it matches `h*`).
$B \to hB$
$B \to \epsilon$

This grammar is [context-free], but not [regular](#what-is-a-regular-grammar), since it has [left-recursion](#what-is-left-recursion) (it matches balanced parentheses).
$S \to S (S)$
$S \to \epsilon$

#### Follow-up questions

- [How can you tell if a language is context-free](#how-can-you-tell-if-a-language-is-context-free)?
- [Is English context-free](http://cs.haifa.ac.il/~shuly/teaching/08/nlp/complexity.pdf)?
- [When a language is context free, do terminals have only one meaning](#what-are-the-implications-of-chomskys-hierarchy)?
- [Is infinite recursion allowed in context-free grammars](#what-is-left-recursion)?

### How can you tell if a language is context-free?

### What is left recursion?

### What is the difference between a regular language and a context free language?

[Formal regular expressions](#what-is-a-regular-expression) define [regular languages](#what-is-a-regular-language),
and can be accepted by [deterministic and non-deterministic](#what-is-the-difference-between-deterministic-and-nondeterministic) [finite state machines](#what-is-a-finite-automaton).
Regular languages also do not accept arbitrary nesting, like [recursion](#what-is-recursion).
[Context-free grammars](#what-is-a-context-free-grammar) define context-free languages, and can be accepted by [pushdown automata](#what-is-a-pushdown-automaton) 

#### Example:

- The [language](#what-is-a-language) of balanced parentheses is context-free, but not regular. Thus, it is impossible to construct a regular expression (but possible to construct a context-free grammar) that matches balanced parentheses.

### What is a derivation?
Give examples.

### What is a leftmost derivation?

### What is a rightmost derivation?

### What is an ambiguous grammar?

### What is a LL(k) grammar?

### What is a LR(k) grammar?

### What is Backus-Naur Form?

A BNF specification is a set of derivation rules, written as

 <symbol> ::= __expression__

where <symbol> is a nonterminal, and the __expression__ consists of one or more sequences of symbols; more sequences are separated by the vertical bar, '|', indicating a choice, the whole being a possible substitution for the symbol on the left. Symbols that never appear on a left side are terminals. On the other hand, symbols that appear on a left side are non-terminals and are always enclosed between the pair <>.

The '::=' means that the symbol on the left must be replaced with the expression on the right

### What is a pushdown automaton?
A pushdown automaton (PDA) is a finite state machine with [stack](#what-is-a-stack) memory. 
It manipulates a stack by choosing an indexing variable within the stack, a current state, and a symbol at the top of the stack. 

> TODO: It'd be nice to have a picture of a pushdown automaton, in a vector format such as SVG.

### What is a deterministic pushdown automaton?

### What is a nondeterministic pushdown automaton?

### What is a parser?
A parser:
- Checks for [syntax errors](#what-is-a-syntax-error)
- Constructs a [parse tree](#what-is-a-parse-tree) or an [abstract syntax tree](#what-is-an-abstract-syntax-tree).

Typically, a [scanner](#what-is-a-scanner) first [tokenizes](#what-is-tokenization) the source code into a [token](#what-is-a-token) [sequence](#what-is-a-sequence) that the parser reads as input.
However, scanner-less parsers work directly with source code as input.

Parsers do not [produce assembly or object code](#what-is-code-generation).

Follow ups:
- [How do parsers work](#how-do-parsers-work)?

### What is a syntax error?

	Syntax of a language is the rule that determines what is allowed in that language. It specifies how a program can be written using statements, loops and functions etc. This rule also applies to how different types of such loops, statements and functions are constructed. Basically, syntax of a programming language is a vocabulary of that language. A syntatically correct program can be sucessfully compiled and interpreted to a machine language. A syntatically incorrect program cannot be compiled and they are supposed to have syntax errors. Syntax errors are errors in the structure of the language. When writing a program, if syntax of the language is not followed, the program will have syntax error.
	
	For e.g, in java programming language, semicolon(;) is required at the end of every statement. If semicolon is not typed after every statement in java, you will get a syntax error while trying to compile your program. Let's see this in the real statement in java.
	Let's say, a programmer wants to display "Hello World!" in his monitor using java programming language.

	System.out.println("Hello Word!");

	This statement displays "Hello Word!" in the monitor without quotations when executed even though programmer meant to type "Hello World!". This is syntatically correct statement and will compile without any error.

	System.out.println("Hello World!")

	In the second example, the program will get syntax error even though "Hello World!" is typed correctly. As we can see, the programmer forgot to type semicolon at the end of the statement. In java, semicolon at the end of the statement is part of its syntax. Hence, a program that doesn't follow the syntax of the language will get a compilation error as the program contains syntax error/s. So, A programmer has to have a detail knowledge of the syntax of the language to be expert in that programming language.

> TODO: this section needs fixing. state what a syntax error is.

A parser first tokenizes the source code depending on its syntax. It takes the structure of the code and uses said tokens to convert it to object code. After evaluation it will convert it to ASM code if there are no syntax errors.

### What is a parse tree?

A parse tree for a grammar G is a tree where

    -the root is the start symbol for G

    -the interior nodes are the nonterminals of G

    -the leaf nodes are the terminal symbols of G.

    -the children of a node T (from left to right) correspond to the symbols on the right hand side of some production for T in G. 

Every terminal string generated by a grammar has a corresponding parse tree; every valid parse tree represents a string generated by the grammar (called the yield of the parse tree). 

### How do parsers work?
